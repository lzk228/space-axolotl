using System.Linq;
using System.Numerics;
using Content.Client.Xenoarchaeology.Artifact;
using Content.Shared.Xenoarchaeology.Artifact.Components;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Input;

namespace Content.Client.Xenoarchaeology.Ui;

[GenerateTypedNameReferences]
public sealed partial class XenoArtifactGraphControl : BoxContainer
{
    [Dependency] private readonly IEntityManager _entityManager = default!;

    private Entity<XenoArtifactComponent>? _artifact;

    private Entity<XenoArtifactNodeComponent>? _hoveredNode;

    private readonly Font _font;

    public event Action<Entity<XenoArtifactNodeComponent>>? OnNodeSelected;

    private static Color _lockedNodeColor = Color.FromHex("#777777");

    private float NodeRadius => 25 * UIScale;
    private float NodeDiameter => NodeRadius * 2;
    private float MinYSpacing => NodeDiameter * 0.75f;
    private float MaxYSpacing => NodeDiameter * 1.5f;
    private float MinXSpacing => NodeDiameter * 0.33f;
    private float MaxXSpacing => NodeDiameter * 1f;
    private float MinXSegmentSpacing => NodeDiameter * 0.5f;
    private float MaxXSegmentSpacing => NodeDiameter * 3f;

    public XenoArtifactGraphControl()
    {
        IoCManager.InjectDependencies(this);
        RobustXamlLoader.Load(this);

        _font = new VectorFont(IoCManager.Resolve<IResourceCache>().GetResource<FontResource>("/EngineFonts/NotoSans/NotoSansMono-Regular.ttf"), 16);
    }

    public void SetArtifact(Entity<XenoArtifactComponent>? artifact)
    {
        _artifact = artifact;
    }

    protected override void KeyBindDown(GUIBoundKeyEventArgs args)
    {
        base.KeyBindDown(args);

        if (args.Handled || args.Function != EngineKeyFunctions.UIClick)
            return;

        if (_hoveredNode == null)
            return;
        OnNodeSelected?.Invoke(_hoveredNode.Value);
        UserInterfaceManager.ClickSound();
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        base.Draw(handle);

        _hoveredNode = null;
        if (_artifact == null)
            return;

        var cursor = (UserInterfaceManager.MousePositionScaled.Position * UIScale) - GlobalPixelPosition;

        var artiSys = _entityManager.System<XenoArtifactSystem>();

        var maxDepth = artiSys.GetAllNodes(_artifact.Value).Max(s => s.Comp.Depth);
        var segments = artiSys.GetSegments(_artifact.Value);

        var bottomLeft = Position // the position
                         + new Vector2(0, Size.Y * UIScale) // the scaled height of the control
                         + new Vector2(NodeRadius, -NodeRadius); // offset half a node so we don't render off screen

        var controlHeight = bottomLeft.Y;
        var controlWidth = Size.X * UIScale - NodeRadius;

        var ySpacing = 0f;
        if (maxDepth != 0)
            ySpacing = Math.Clamp((controlHeight - ((maxDepth + 1) * NodeDiameter)) / maxDepth, MinYSpacing, MaxYSpacing);

        var segmentWidths = segments.Sum(GetBiggestWidth);
        var segmentSpacing = Math.Clamp((controlWidth - segmentWidths) / (segments.Count - 1), MinXSegmentSpacing, MaxXSegmentSpacing);
        var segmentOffset = Math.Max((controlWidth - (segmentWidths) - (segmentSpacing * (segments.Count - 1))) / 2, 0);

        bottomLeft.X += segmentOffset;
        bottomLeft.Y -= (controlHeight - (ySpacing * maxDepth) - (NodeDiameter * (maxDepth + 1))) / 2;

        foreach (var segment in segments)
        {
            var orderedNodes = artiSys.GetDepthOrderedNodes(segment);

            foreach (var (_, nodes) in orderedNodes)
            {
                for (var i = 0; i < nodes.Count; i++)
                {
                    var node = nodes[i];
                    var pos =  GetNodePos(node);
                    var hovered = (cursor - pos).LengthSquared() <= NodeRadius * NodeRadius;

                    var color = _lockedNodeColor;
                    if (artiSys.IsNodeActive(_artifact.Value, node))
                    {
                        color = Color.Plum;
                    }
                    else if (!node.Comp.Locked)
                    {
                        color = Color.White;
                    }

                    if (hovered)
                    {
                        _hoveredNode = node;
                        handle.DrawCircle(pos, NodeRadius, Color.DimGray);
                    }

                    handle.DrawCircle(pos, NodeRadius, Color.ToSrgb(color), false);

                    var text = artiSys.GetNodeId(node);
                    var dimensions = handle.GetDimensions(_font, text, 1);
                    handle.DrawString(_font, pos - new Vector2(dimensions.X / 2, dimensions.Y / 2), text, color);
                }
            }

            foreach (var node in segment)
            {
                var from = GetNodePos(node) + new Vector2(0, -NodeRadius);
                var successors = artiSys.GetDirectSuccessorNodes((_artifact.Value, _artifact.Value.Comp), node);
                foreach (var s in successors)
                {
                    var color = _lockedNodeColor;
                    if (!node.Comp.Locked)
                        color = Color.White;

                    var to = GetNodePos(s) + new Vector2(0, NodeRadius);
                    handle.DrawLine(from, to, color);
                }
            }

            bottomLeft.X += GetBiggestWidth(segment) + segmentSpacing;
        }

        Vector2 GetNodePos(Entity<XenoArtifactNodeComponent> node)
        {
            var yPos = -(NodeDiameter + ySpacing) * node.Comp.Depth;

            var segment = segments.First(s => s.Contains(node));
            var depthOrderedNodes = artiSys.GetDepthOrderedNodes(segment);
            var biggestTier = depthOrderedNodes.Max(s => s.Value.Count);
            var nodesInLayer = depthOrderedNodes.GetValueOrDefault(node.Comp.Depth)!.Count;
            var biggestWidth = (NodeDiameter + MinXSpacing) * biggestTier;

            var xSpacing = Math.Clamp((biggestWidth - (NodeDiameter * nodesInLayer)) / (nodesInLayer - 1), MinXSpacing, MaxXSpacing);
            var layerXOffset = (biggestWidth - (xSpacing * (nodesInLayer - 1)) - (NodeDiameter * nodesInLayer)) / 2;

            var index = depthOrderedNodes.GetValueOrDefault(node.Comp.Depth)!.IndexOf(node);

            var xPos = NodeDiameter * index + (xSpacing * index) + layerXOffset;

            return bottomLeft + new Vector2(xPos, yPos);
        }
    }

    private float GetBiggestWidth(List<Entity<XenoArtifactNodeComponent>> nodes)
    {
        var artiSys = _entityManager.System<XenoArtifactSystem>();
        var num = artiSys.GetDepthOrderedNodes(nodes).Max(p => p.Value.Count);
        return (NodeDiameter * num) + MinXSpacing * (num - 1);
    }
}

